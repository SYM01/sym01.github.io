<!doctype html>
<html>
  <head>
    <title>利用 multipart boundary 绕过 WAF // SYM01&#39;s BLOG</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="SYM01" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.b73fbf13c263460a9b664bb1b2f5d1570dc20408d8dac29fdb0e90bc26483077.css" />
  </head>
  <body>
    <header class="app-header">
      <a href="/"><img class="app-header-avatar" src="/avatar.jpg" /></a>
      <h1>SYM01&#39;s BLOG</h1>
      <p>Stay Young, Stay Naive.</p>
      <div class="app-header-social">
        <a target="_blank" href="https://github.com/SYM01"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a>
        </div>
    </header>
    <main class="app-container">
      <a class="search" href="/search/">
        <svg t="1573031963095" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M1008.64 933.302857l-142.628571-142.628571A484.937143 484.937143 0 0 0 830.902857 146.285714 486.4 486.4 0 0 0 146.285714 146.285714a486.4 486.4 0 0 0 0 688.274286 489.325714 489.325714 0 0 0 341.577143 138.24 477.622857 477.622857 0 0 0 159.451429-27.062857 52.662857 52.662857 0 0 0 32.914285-68.022857 53.394286 53.394286 0 0 0-68.022857-32.914286 380.342857 380.342857 0 1 1 146.285715-89.965714 52.662857 52.662857 0 0 0 0 73.142857l177.737142 177.737143a53.394286 53.394286 0 0 0 37.302858 15.36 54.857143 54.857143 0 0 0 38.034285-15.36 54.125714 54.125714 0 0 0-2.925714-72.411429z" p-id="2846" fill="currentColor"></path></svg>
        <span>搜索</span>
      </a>
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">利用 multipart boundary 绕过 WAF</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
          2021-08-02 02:28
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
          3 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>
          <a class="tag" href="https://sym01.com/tags/golang/">Golang</a><a class="tag" href="https://sym01.com/tags/bypass/">Bypass</a><a class="tag" href="https://sym01.com/tags/waf/">WAF</a></div></div>
    </header>
    <div class="post-content">
      <h2 id="0x00-前言">0x00 前言</h2>
<p>WAF（Web Application Firewall）是很常见的 Web 安全基础设施，许多云厂商、大厂、乙方安全公司均有相应的产品。然而，不得不承认，WAF 只能<strong>有限</strong>提升安全防护能力，不能拦截一些稍微复杂的攻击。正常业务不应当过度依赖 WAF，况且 WAF 还存在误拦截正常业务流量的可能。</p>
<p>目前已知的一些绕过 WAF 的手段包括但不限于：</p>
<ul>
<li>Chunked encoding 绕过</li>
<li>IBM037 等罕见编码绕过</li>
</ul>
<blockquote>
<p>多嘴一句：最早提出 IBM037 编码绕过 WAF 的应该是 Soroush Dalili 在 <a href="https://www.slideshare.net/SoroushDalili/a-forgotten-http-invisibility-cloak">SteelCon 2017 上议题</a>，然而国内众多相关文章，基本没有标记出处，很奇怪。</p>
</blockquote>
<p>笔者最近在分析 Go 语言的 HTTP 协议解析实现的时候，发现了一种能够利用 multipart boundary 绕过 WAF 的方法，在 Python 的一些 Web 框架上也适用，因而将其分享出来。</p>
<h2 id="0x01-绕过">0x01 绕过</h2>
<p><code>multipart/form-data</code> 是一种非常常见的 HTML 表单编码方式，绝大部分的 Web 服务器、框架实现，均支持此编码。其编码后的请求大致如下所示，表单数据通过<code>boundary</code>分割。</p>
<div class="highlight"><pre class="chroma"><code class="language-http" data-lang="http"><span class="nf">POST</span> <span class="nn">/test</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="n">Host</span><span class="o">:</span> <span class="l">example.com</span>
<span class="n">Content-Type</span><span class="o">:</span> <span class="l">multipart/form-data; boundary=“boundary”</span>

—boundary
Content-Disposition: form-data; name=“field1”

value1
—boundary
Content-Disposition: form-data; name=“field2”; filename=“example.txt”

value2
—boundary—
</code></pre></div><p>那么只要满足上述协议要求，服务端就可以正常获取到字段内容了，如下图所示。
<img src="./980F2804-97C8-43C8-A106-1238BA2EF1DE.png" alt="980F2804-97C8-43C8-A106-1238BA2EF1DE.png"></p>
<p>那么如果构造多个 boundary 会有什么效果？很遗憾，一些服务端实现（比如 Go 语言）不允许多个 boundary，数据传递失败：
<img src="./3D93AC2B-78F4-4AE0-8115-7F9598E4F1E8.png" alt="3D93AC2B-78F4-4AE0-8115-7F9598E4F1E8.png"></p>
<p>多个 Content-Type 倒是可行，然而多数服务端，包括 WAF 的实现，基本上只认第一个出现的 Content-Type 。</p>
<p>只能另辟蹊径。</p>
<h3 id="回到协议解析本身">回到协议解析本身</h3>
<p>在 Go 语言的实现中，<code>multipart/form-data</code> 中对 boundary 的解析是通过 <a href="https://pkg.go.dev/mime#ParseMediaType"><code>mime.ParseMediaType</code></a> 实现的：
<img src="./EC6E636A-C3F6-402C-B804-1D1331F01F3A.png" alt="EC6E636A-C3F6-402C-B804-1D1331F01F3A.png"></p>
<p>然而 <a href="https://pkg.go.dev/mime#ParseMediaType"><code>mime.ParseMediaType</code></a> 对 MediaType 参数的解析有个有趣的细节，正常情况下，参数不允许重复，如下图 190行 所示，这也是上文请求失败的原因。
<img src="./FA7B1D3E-F4DA-4E43-88D8-B4FE670E46F4.png" alt="FA7B1D3E-F4DA-4E43-88D8-B4FE670E46F4.png"></p>
<p>然而在 203行 处，却允许参数的<strong>覆盖</strong>，只要目标参数满足 <a href="https://datatracker.ietf.org/doc/html/rfc2231#section-3">RFC 2231</a> 的格式。<a href="https://datatracker.ietf.org/doc/html/rfc2231#section-3">RFC 2231</a>中描述了一种名为 <code>Parameter Value Continuations</code> 的规范，其核心部分如下图所示，大意是一个参数<code>URL</code>，可以等价拆成两个分别名为<code>URL*0</code>、<code>URL*1</code>的参数。
<img src="./7D8453CC-45F6-4D69-96D6-D507ADADFF7F.png" alt="7D8453CC-45F6-4D69-96D6-D507ADADFF7F.png"></p>
<p>那么，boundary 能否通过同样的方式覆盖呢？实际测试一下，发现可行。Go 会将<code>boundary*0=&quot;real-&quot;;boundary*1=&quot;boundary&quot;</code> 当作最终的 boundary 。
<img src="./82975742-B2FE-4EAD-A6A5-D1525696C787.png" alt="82975742-B2FE-4EAD-A6A5-D1525696C787.png"></p>
<h3 id="绕过某云-waf">绕过某云 WAF</h3>
<p>上节中提到的怪异但符合<code>Parameter Value Continuations</code> 规范的数据包，应该是一个绕过 WAF 的神器。笔者随即写了一个存在 SQL 注入漏洞的服务，挂在某国内领头羊云厂商的 WAF 后面进行测试，证实了这个猜想。</p>
<p>这个测试服务的 <code>id</code> 字段存在注入，正常情况下，因为没有任何攻击特征，WAF 不会拦截：
<img src="./7232CF94-E2EF-45D1-B7ED-684F0F57929B.png" alt="7232CF94-E2EF-45D1-B7ED-684F0F57929B.png"></p>
<p>进行注入，WAF 会正常拦截：
<img src="./F9AB457D-3A91-4EB4-A218-77163869273F.png" alt="F9AB457D-3A91-4EB4-A218-77163869273F.png"></p>
<p>然而当我们请出 <a href="https://datatracker.ietf.org/doc/html/rfc2231#section-3">RFC 2231</a> 大爷，整个注入攻击变得畅通无阻。
<img src="./F67A0842-26E6-47F6-B31F-8A412A470091.png" alt="F67A0842-26E6-47F6-B31F-8A412A470091.png"></p>
<p>本质上是利用了 WAF 和 服务端 的协议解析差异来绕过防护的，应当可以绕过一大票 WAF 产品。这里没有一一测试各家产品，不是为了避免拿来党，主要还是因为懒。</p>
<h2 id="0x02-举一反三">0x02 举一反三</h2>
<p>上述绕过方式是基于 <a href="https://datatracker.ietf.org/doc/html/rfc2231#section-3">RFC 2231</a> 的，因此其它支持  <a href="https://datatracker.ietf.org/doc/html/rfc2231#section-3">RFC 2231</a>  的服务端实现也应当可以绕过。笔者对比较流行的 Python 框架 —— Flask 进行了测试，毫无意外地利用成功了。然而 Flask 的服务端实现和 Go 有细微的差异，最终解析出来的 boundary 参数，会拼接原始的 boundary 参数，如下图所示。
<img src="./76363B51-0E0C-4B6D-A1A0-56DD27A84E26.png" alt="76363B51-0E0C-4B6D-A1A0-56DD27A84E26.png"></p>
<p>其它语言、框架应有类似的特性。</p>
<h2 id="0x03-总结">0x03 总结</h2>
<p>WAF 绕过的本质是利用了 WAF 和 服务端 的协议解析差异。类似的差异应该还有许多。最后重复一下一开始提到的观点：WAF 并不可靠，不要过度依赖 WAF。</p>

    </div>
  </article>
  <script src="https://utteranc.es/client.js"
        repo="SYM01/sym01.github.io"
        issue-term="pathname"
        theme="dark-blue"
        crossorigin="anonymous"
        async>
  </script>
  </main>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111333897-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-111333897-1');
    </script>
    </body>
</html>
