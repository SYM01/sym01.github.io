<!doctype html><html>
<head>
<title>利用 multipart boundary 绕过 WAF // SYM01's BLOG</title>
<meta charset=utf-8>
<meta name=generator content="Hugo">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="SYM01">
<meta name=description content>
<link rel=stylesheet href=/css/main.min.a01dfcfaeb068a04422983e4e81f02c0158aca88c0c3be786620bb974cce87a2.css>
</head>
<body>
<header class=app-header>
<a href=/><img class=app-header-avatar src=/avatar.jpg></a>
<h1>SYM01's BLOG</h1>
<p>Stay Young, Stay Naive.</p>
<div class=app-header-social>
<a target=_blank href=https://github.com/SYM01><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a>
</div>
</header>
<main class=app-container>
<a class=search href=/search/><svg t="1573031963095" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M1008.64 933.302857 866.011429 790.674286A484.937143 484.937143.0 00830.902857 146.285714a486.4 486.4.0 00-684.617143.0 486.4 486.4.0 000 688.274286A489.325714 489.325714.0 00487.862857 972.8a477.622857 477.622857.0 00159.451429-27.062857 52.662857 52.662857.0 0032.914285-68.022857A53.394286 53.394286.0 00612.205714 844.8a380.342857 380.342857.0 11146.285715-89.965714 52.662857 52.662857.0 000 73.142857l177.737142 177.737143a53.394286 53.394286.0 0037.302858 15.36 54.857143 54.857143.0 0038.034285-15.36A54.125714 54.125714.0 001008.64 933.302857z" p-id="2846" fill="currentcolor"/></svg>
<span>搜索</span>
</a>
<article class=post>
<header class=post-header>
<h1 class=post-title>利用 multipart boundary 绕过 WAF</h1>
<div class=post-meta>
<div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-08-02 02:28
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
3 min read
</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<a class=tag href=https://sym01.com/tags/golang/>Golang</a><a class=tag href=https://sym01.com/tags/bypass/>Bypass</a><a class=tag href=https://sym01.com/tags/waf/>WAF</a></div></div>
</header>
<div class=post-content>
<h2 id=0x00-前言>0x00 前言</h2>
<p>WAF（Web Application Firewall）是很常见的 Web 安全基础设施，许多云厂商、大厂、乙方安全公司均有相应的产品。然而，不得不承认，WAF 只能<strong>有限</strong>提升安全防护能力，不能拦截一些稍微复杂的攻击。正常业务不应当过度依赖 WAF，况且 WAF 还存在误拦截正常业务流量的可能。</p>
<p>目前已知的一些绕过 WAF 的手段包括但不限于：</p>
<ul>
<li>Chunked encoding 绕过</li>
<li>IBM037 等罕见编码绕过</li>
</ul>
<blockquote>
<p>多嘴一句：最早提出 IBM037 编码绕过 WAF 的应该是 Soroush Dalili 在 <a href=https://www.slideshare.net/SoroushDalili/a-forgotten-http-invisibility-cloak>SteelCon 2017 上的议题</a>，然而国内众多相关文章，基本没有标记出处，很奇怪。</p>
</blockquote>
<p>笔者最近在分析 Go 语言的 HTTP 协议解析实现的时候，发现了一种能够利用 multipart boundary 绕过 WAF 的方法，在 Python 的一些 Web 框架上也适用，因而将其分享出来。</p>
<h2 id=0x01-绕过>0x01 绕过</h2>
<p><code>multipart/form-data</code> 是一种非常常见的 HTML 表单编码方式，绝大部分的 Web 服务器、框架实现，均支持此编码。其编码后的请求大致如下所示，表单数据通过<code>boundary</code>分割。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/test</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>example.com</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>multipart/form-data; boundary=“boundary”</span>

—boundary
Content-Disposition: form-data; name=“field1”

value1
—boundary
Content-Disposition: form-data; name=“field2”; filename=“example.txt”

value2
—boundary—
</code></pre></div><p>那么只要满足上述协议要求，服务端就可以正常获取到字段内容了，如下图所示。
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/980F2804-97C8-43C8-A106-1238BA2EF1DE_hub9179d1315e3e6adb71b9d22fceaf4fd_80749_2462x382_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./980F2804-97C8-43C8-A106-1238BA2EF1DE.png loading=lazy decoding=async>
</picture></p>
<p>那么如果构造多个 boundary 会有什么效果？很遗憾，一些服务端实现（比如 Go 语言）不允许多个 boundary，数据传递失败：
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/3D93AC2B-78F4-4AE0-8115-7F9598E4F1E8_hu445bac65aceb53033ab3820b944ecf7a_105409_2458x530_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./3D93AC2B-78F4-4AE0-8115-7F9598E4F1E8.png loading=lazy decoding=async>
</picture></p>
<p>多个 Content-Type 倒是可行，然而多数服务端，包括 WAF 的实现，基本上只认第一个出现的 Content-Type 。</p>
<p>只能另辟蹊径。</p>
<h3 id=回到协议解析本身>回到协议解析本身</h3>
<p>在 Go 语言的实现中，<code>multipart/form-data</code> 中对 boundary 的解析是通过 <a href=https://pkg.go.dev/mime#ParseMediaType><code>mime.ParseMediaType</code></a> 实现的：
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/EC6E636A-C3F6-402C-B804-1D1331F01F3A_hu8a5f30cf806ba372c88914d637b57057_141518_1488x630_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./EC6E636A-C3F6-402C-B804-1D1331F01F3A.png loading=lazy decoding=async>
</picture></p>
<p>然而 <a href=https://pkg.go.dev/mime#ParseMediaType><code>mime.ParseMediaType</code></a> 对 MediaType 参数的解析有个有趣的细节，正常情况下，参数不允许重复，如下图 190行 所示，这也是上文请求失败的原因。
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/FA7B1D3E-F4DA-4E43-88D8-B4FE670E46F4_hu4d3076d4fc264ecc00b6eca11286f3a8_237199_1264x1242_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./FA7B1D3E-F4DA-4E43-88D8-B4FE670E46F4.png loading=lazy decoding=async>
</picture></p>
<p>然而在 203行 处，却允许参数的<strong>覆盖</strong>，只要目标参数满足 <a href=https://datatracker.ietf.org/doc/html/rfc2231#section-3>RFC 2231</a> 的格式。<a href=https://datatracker.ietf.org/doc/html/rfc2231#section-3>RFC 2231</a>中描述了一种名为 <code>Parameter Value Continuations</code> 的规范，其核心部分如下图所示，大意是一个参数<code>URL</code>，可以等价拆成两个分别名为<code>URL*0</code>、<code>URL*1</code>的参数。
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/7D8453CC-45F6-4D69-96D6-D507ADADFF7F_hu241093be7ffbd822903da8d4e11ead21_76036_1120x398_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./7D8453CC-45F6-4D69-96D6-D507ADADFF7F.png loading=lazy decoding=async>
</picture></p>
<p>那么，boundary 能否通过同样的方式覆盖呢？实际测试一下，发现可行。Go 会将<code>boundary*0="real-";boundary*1="boundary"</code> 当作最终的 boundary 。
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/82975742-B2FE-4EAD-A6A5-D1525696C787_hub091f6d7b79794396269db3b4a67d987_120193_2460x578_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./82975742-B2FE-4EAD-A6A5-D1525696C787.png loading=lazy decoding=async>
</picture></p>
<h3 id=绕过某云-waf>绕过某云 WAF</h3>
<p>上节中提到的怪异但符合<code>Parameter Value Continuations</code> 规范的数据包，应该是一个绕过 WAF 的神器。笔者随即写了一个存在 SQL 注入漏洞的服务，挂在某国内领头羊云厂商的 WAF 后面进行测试，证实了这个猜想。</p>
<p>这个测试服务的 <code>id</code> 字段存在注入，正常情况下，因为没有任何攻击特征，WAF 不会拦截：
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/7232CF94-E2EF-45D1-B7ED-684F0F57929B_huc3e517344593c5d7ae8cff4d5b9704d4_108304_2450x472_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./7232CF94-E2EF-45D1-B7ED-684F0F57929B.png loading=lazy decoding=async>
</picture></p>
<p>进行注入，WAF 会正常拦截：
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/F9AB457D-3A91-4EB4-A218-77163869273F_hud59d1bdbe18be739c3c470d3d2e0ba53_450465_2458x1278_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./F9AB457D-3A91-4EB4-A218-77163869273F.png loading=lazy decoding=async>
</picture></p>
<p>然而当我们请出 <a href=https://datatracker.ietf.org/doc/html/rfc2231#section-3>RFC 2231</a> 大爷，整个注入攻击变得畅通无阻。
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/F67A0842-26E6-47F6-B31F-8A412A470091_hu9ac4f13faf95e4dad1b0dfef1141e691_153266_2456x590_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./F67A0842-26E6-47F6-B31F-8A412A470091.png loading=lazy decoding=async>
</picture></p>
<p>本质上是利用了 WAF 和 服务端 的协议解析差异来绕过防护的，应当可以绕过一大票 WAF 产品。这里没有一一测试各家产品，不是为了避免拿来党，主要还是因为懒。</p>
<h2 id=0x02-举一反三>0x02 举一反三</h2>
<p>上述绕过方式是基于 <a href=https://datatracker.ietf.org/doc/html/rfc2231#section-3>RFC 2231</a> 的，因此其它支持 <a href=https://datatracker.ietf.org/doc/html/rfc2231#section-3>RFC 2231</a> 的服务端实现也应当可以绕过。笔者对比较流行的 Python 框架 —— Flask 进行了测试，毫无意外地利用成功了。然而 Flask 的服务端实现和 Go 有细微的差异，最终解析出来的 boundary 参数，会拼接原始的 boundary 参数，如下图所示。
<picture>
<source srcset=/posts/2021/bypass-waf-via-boundary-confusion/76363B51-0E0C-4B6D-A1A0-56DD27A84E26_hu0c70246b7f66314b21ad182834a60a3f_137322_2454x600_resize_q90_h2_lanczos_3.webp type=image/webp>
<img src=./76363B51-0E0C-4B6D-A1A0-56DD27A84E26.png loading=lazy decoding=async>
</picture></p>
<p>其它语言、框架应有类似的特性。</p>
<h2 id=0x03-总结>0x03 总结</h2>
<p>WAF 绕过的本质是利用了 WAF 和 服务端 的协议解析差异。类似的差异应该还有许多。最后重复一下一开始提到的观点：WAF 并不可靠，不要过度依赖 WAF。</p>
</div>
</article>
<script src=https://utteranc.es/client.js repo=SYM01/sym01.github.io issue-term=pathname theme=dark-blue crossorigin=anonymous async></script>
</main>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EH6W0S669D"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-EH6W0S669D')</script>
</body>
</html>